---
marp: true
_class: invert
---

# Ch 1. 성능과 최적화

- [Ch 1. 성능과 최적화](#ch-1-성능과-최적화)
  - [책을 읽기 전에](#책을-읽기-전에)
  - [Introduction](#introduction)
  - [Ch 1. 성능과 최적화](#ch-1-성능과-최적화-1)
    - [1.1 자바 성능 : 잘못된 방법](#11-자바-성능--잘못된-방법)
    - [1.2 자바 성능 개요](#12-자바-성능-개요)
    - [1.3 성능은 실험과학이다](#13-성능은-실험과학이다)
    - [1.4 성능 분류 지표](#14-성능-분류-지표)
    - [1.5 성능 그래프 읽기](#15-성능-그래프-읽기)
    - [1.6 마치며](#16-마치며)


----

## 책을 읽기 전에

- 왜 자바 성능 최적화는 보편화되지 못했는가? JMeter, Profiling 같은 키워드는 차치하고, 왜 다른 어플리케이션 주변부의 Java 기술(TDD - JUnit) 만큼 대중화되지 못했는가? `성능`만큼 보편적이고 중요한 키워드가 별로 없는데도 말이다.
- 대중화되지 못했다면 러닝 커브가 있다고 판단된다. 예를 들어 `OutOfMemoryError`가 발생할 때 서버메모리증설(`Scale Up`)을 계속해도 해결되지 않은 사례가 있다. 결국 일일이 측정을 해보니 _특정 객체의 메모리 누수 현상_ 으로 밝혀졌다고 한다.
- 또 많은 상황에서 `성능`보다는 `작동여부`와 어느정도의 `유지보수성` 초점을 맞추어 개발하는 경우가 더 많다. 성능이슈가 심각해지고 나서야 `성능`에 대해 고찰해보기 때문이기도 하다. 일반적인 부하테스트, 성능테스트로는 잡지 못하고 엔드유저 사용 시에 발생하는 `성능`이슈가 많다.

> 결국 중요한 질문 - 상황에 따라 적절한 최적화를 하려면 _**어떤 종류의 통찰력**_ 이 필요한가?

----

<!-- footer : 13p -->
## Introduction

- JIT과 GC 기술이 발전하면서 애플리케이션 성능을 어떻게 개선해야 하는지 방향을 정하기 어려워졌음.
  - 대부분의 처리는 좋은 코딩 패턴으로 : 작은 메서드를 적절히 인라이닝, 인터페이스 및 타입 체크는 저렴하게 처리,  JIT 컴파일러가 만든 네이티브 코드는 간결하고 효율적으로 유지
  - 그러나, 경우에 따라 사람이 직접 코드를 작성하고 컴파일러 및 CPU를 리밋을 감안해 추상화와 아키텍처를 재조정해야 하는 경우 있음. 
- 모든 성능 문제는 한 가지 정답이 있는게 아니라, 여러 개의 정답이 있다.  

----

<!-- footer : 25p -->
## Ch 1. 성능과 최적화  


> 성능 분석은 경험주의와 질퍽한 인간 심리학이 교묘히 어우러진 분야이다. 
> 가장 중요한 건 관측 지표의 절대 수지, 엔드 유저와 기타 이해관계자들이 그 수치를 어떻게 받아들이는가 이다.

----
<!-- footer : 26p ~ 27p -->
### 1.1 자바 성능 : 잘못된 방법 
- 자바 초창기 기준의 성능 튜닝 방법을 지금도 적용하면 안된다. 
    - ex) 초기 자바 디스패치 성능 나쁨 -> 메서드를 쪼개지 말고 하나에 넣어라 -> 현대 JIT과는 어울리지 않음
- 코드에 바로 써먹을 수 있는 성능 팁을 나열할 목적으로 책을 쓰지 않았다. 책의 마지막 부분에 소개.
- 그대신 다음 여러 측면에서 조명하는 식으로 기술
  - 전체 소프트웨어 수명주기의 성능방법론
  - 성능과 연관된 테스트 이론
  - 측정, 통계, 도구 선정
  - 시스템 + 데이터 분석 스킬

--- 

<!-- footer : 26p ~ 27p -->
- 일반적인 원칙
    - JVM을 더 빨리 작동시키는 마법의 스위치 같은 건 없습니다.
    - 자바를 더 빨리 실행하게 만드는 팁, 트릭은 없습니다.
    - 여러분이 못 보게 꼭꼭 숨겨둔 비밀 알고리즘 같은 것도 없습니다. 

----
<!-- footer : 30p~ 31p -->
### 1.2 자바 성능 개요 

- 자바는 처음부터 지극히 실용적인 언어였다. 개발 환경이 충분히 빠르다면 개발자 생산성이 높아지는 대가로 어느정도의 성능 희생은 감수할 만하다. 충분히 빨라진 건 비교적 최근의 Hotspot 같은 정교한 JVM이 성숙했기 때문.
- 서브시스템(managed subsystem) : 개발자가 일일이 용량을 세세하게 관리하는 부담을 덜어주고, 대신 저수준으로 제어 가능한 일부 기능을 포기하자
- 메모리 관리 : JVM이 **탈착형 가비지 수집 서브시스템** 형태로 메모리를 자동관리하는 덕분에 프로그래머는 수도응로 메모리를 의식하며 개발할 필요가 없음.

----

<!-- footer : 30p~ 31p -->
- JVM 어플리케이션의 성능 측정값은 정규 분포를 따르지 않는 경우가 많다. 그래서 기초 통계기법(표준편차, 분산)으로만 측정 결과를 제대로 분석하기엔 부족하다.
- 특히 자바 성능 분석에서 **아웃라이어는 매우 중요한 의미를 내포할 수 있다**. 즉, 측정값을 _샘플링(표본추출)_하면 특이점이 발생한 가장 중요한 이벤트가 묻혀버릴 가능성이 크다.
- 환경이 복잡해질수록 시스템을 개별적으로 따로 뗴어내 생각하기는 몹시 어렵다.
- 측정하는 행위 자체도 오버헤드를 일으키며, 너무 자주 샘플링하거나 매번 결과를 기록하는 것 역시 성능 결과 수치에 적잖은 영향을 끼친다.
- 자바 성능 수치는 일정 부분 _세심한 손질이 필요하다_.

----

<!-- footer : 31p~ 32p -->
### 1.3 성능은 실험과학이다

> 소프트웨어 산업의 가장 경이적인 성과는 하드웨어 산업에서 꾸준히 이루어낸 혁실을 끊임없이 무용지물로 만들고 있는 것이다. - _헨리 페트로스키_

- JVM도 다른 복잡한 고성능 시스템처럼 최상의 성능을 발휘하려면 어느 수준 이상의 스킬과 경험이 필요합니다. 

> 명확하게 정의하지 않고 측정하는 건 백해무익하다. - _엘리 골드렛_

----
<!-- footer : 31p~ 32p -->
- 성능은 다음과 같은 활동을 하면서 원하는 결과를 얻기 위한, 일종의 **실험과학**이라고 볼 수 있다. 
```
- 원하는 결과를 정의한다.
- 기존 시스템을 측정한다.
- 요건을 충족시키려면 무슨 일을 해야 할지 정한다.
- 개선 활동을 추진한다.
- 다시 테스트한다.
- 목표가 달성됐는지 판단한다.
```
----
<!-- footer : 31p~ 32p -->
- 바람직한 성능 결과를 정의하고 판단하는 과정에서 정량적인 일련의 목표가 수립됩니다. 무엇을 측정할지 대상을 확정하고 목표를 기록하는 행위가 중요한데, 결국 이런 활동들이 프로젝트 아티팩트 _artifact_ 와 제품 일부를 형성한다. 

- 성능 분석은 비기능 요건을 정의하고 달성하는 활동. 닭을 해부해보거나 점을 치는 과정이 아니라, 통계치에 근거해 적절히 결과를 처리하는 활동. 기본 통계 기법은 5장에서 소개.

----
<!-- footer : 32p ~ 36p -->
### 1.4 성능 분류 지표

- 성능 지표는 성능 목표를 정의한 비기능 요건.
- 기본적인 성능 지표 목록. 

----
<!-- footer : 32p ~ 36p -->
| 용어 (한국어) | Term (English) | 설명 (한국어) |
| ------------- | -------------- | ------------ |
| 처리율 | Throughput | (서브)시스템이 수행 가능한 작업 비율을 나타낸 지표. 일정시간동안 완료한 작업 단위 수로 표시(예 : 초당 처리 가능한 트랜잭션 수). 기준 플랫폼, 트랜잭션과 실행간 워크로드 테스트마다 동일한지 체크해야. |
| 지연 | Latency | 하나의 트랜잭션을 처리하고 그 결과를 반대편 수도관 끝에서 바라볼 때까지 소요된 시간. 종단 시간. |
| 용량 | Capacity | 시스템이 동시 처리 가능한 작업 단위(트랜잭션) 개수. 용량은 처리율과 밀접한 연관이 있다. |
| 사용률 | Utilization | 워크로드에 따라 리소스별로 들쑥날쑥함. ex) 계산집약적인 워크로드 -> CPU 사용률은 100%이지만, 메모리 사용률은 낮음 |
| 효율 | Efficiency | 처리율을 리소스 사용률로 나눈 값 |
| 확장성 | Scalability | 정확히 리소스를 투입한 만큼 처리율이 변경되는 형태를 지향함. |
| 저하 | Degradation | 시스템이 풀 가동된 상태면 처리율이 더는 늘어나지 않는, 즉 지연이 증가하는 양상을 띤다. 부하 증가에 따른 저하라고 함. |

----
<!-- footer : 32p ~ 36p -->
> 보통 **시스템 확장성**은 하나의 단순한 **상수** 인자가 **아니라**, **여러 가지 인자들의 영향**을 받음. 리소스를 어느정도까지 늘리면 거의 선형적으로 확장되지만, 대부분 부하가 높아지면 완벽한 확장을 저해하는 한계점에 봉착한다.

- 측정값 사이의 연관 관계 : 다양한  성능 측정값은 어떤 식으로든 서로 연결되어 있다. 시스템에 상당한 부하가 걸려 있는 상태면 부하가 조금만 늘어도 다른 측정값이 크게 요동칠 수 있다. 

----
<!-- footer : 37p ~ 40p -->
### 1.5 성능 그래프 읽기

**그래프 예시 1-1 : 성능엘보 peformance elbow**
- 부하가 증가하면서 지연이 발생한 그래프

![peformance elbow](https://4.bp.blogspot.com/-iPeZrmhPiq4/VbcLvbpKlfI/AAAAAAAAB18/suBPMzHlzEQ/s1600/Slide19.png)

----

<!-- footer : 37p ~ 40p -->
**그래프 예시 1-2 : 클러스터에 장비를 추가하면서 거의 선형적으로 처리율 확장**
- 이상적인 케이스
- 서버 하나에 세션 고정 _session affinity_ 가 필요없는, 무상태 프로토콜을 확장하는 경우

![](../static/image/near_linear_graph.png)

----
<!-- footer : 37p ~ 40p -->
**그래프 예시 1-3 : 암달의 법칙**
- 확장성에는 근본적인 제약이 따른다.
- 프로세서 개수를 늘렸을때 실행 속도를 최대 어느 정도까지 높일 수 있는지 나타낸 그래프 

----
<!-- footer : 37p ~ 40p -->

![Amdahl's law](https://i.namu.wiki/i/q__7XQpfAfe9uiLSW72qblfAZWoOGI_DRlpkaWzu7TMrD8RBUfaBJcVeufywqyyokmrmzOLDFEpuEPuHJZ80vA.webp)

- 워크로드에 반드시 순차 실행되어야 할 작업 조각이 하나라도 있으면 선형확장은 처음부터 불가하면 확장 가능한 한계점도 뚜렸하다.
- 최선의 경우라도 사실상 선형 확장은 불가능한 미션이다. 
- 순차 비율이 5%인 알고리즘도 12배 시간을 단축하려면 프로세서가 32개나 필요하고, 코어를 아주 많이 늘려도 20배이상 시간 단축은 어려움.


----
<!-- footer : 37p ~ 40p -->
**그래프 예시 1-4 : JVM 가비지 수집 서브시스템의 메모리 사용패턴 - 톱니모양**

- 부하가 없는 건강한 어플리케이션도 톱니모양임 

![건강한 어플리케이션의 메모리 사용 현황](https://i0.wp.com/blog.ycrash.io/wp-content/uploads/2021/10/image.png?w=736&ssl=1)

---

<!-- footer : 37p ~ 40p -->
**그래프 예시 1-5 : 메모리 할당률 그래프**
- 메모리 할당률 _memory allocation rate_
- 피보나치 수열을 계산시 가비지 수집 스레드들이 서로 CPU 경합을 벌인탓에 메모리를 충분히 할당받지 못했음.
- 할당 서브시스템도 4GB/s라는 속도로 메모리를 할당함. 최신 시스템의 권장 최대 용량을 훨씬 웃도는 수준

----
<!-- footer : 37p ~ 40p -->
![memory allocation rate](https://i.stack.imgur.com/yki6P.png)


---- 

<!-- footer : 37p ~ 40p -->
**그래프 예시 1-6 : 시스템 리소스 누수**
- 흔히 나타남.
- 부하가 증가하면서 지연시간이 차츰 악화되다가 결국 시스템 성능이 급락하는 변곡점 _inflection point_ 이름
- 특정 시점 이후로는 가비지 컬렉션 이후에도 남는 메모리가 계속 줄어든다. 

----
<!-- footer : 37p ~ 40p -->
![bg 50%](https://jet-start.sh/blog/assets/2020-08-05-latency-1m.png)

----
### 1.6 마치며 
- 다음장 JVM 기반의 성능 최적화가 왜 그렇게 복잡한가 알아볼것
