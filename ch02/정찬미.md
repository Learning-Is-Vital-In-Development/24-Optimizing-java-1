---
marp: true
_class: lead
---

<!-- footer : 41p -->
# Ch 2. JVM 이야기

> 자바는 개발자가 플랫폼을 저수준에서 다 알 필요가 없도록 설계되었다. 
> 그래서 고객이 성능이 느리다고 얘기해도 개발자는 내가 할 일은 다 했다고 생각할 수 있다.
> 그러나 성능에 관심 있는 개발자라면 기본적인 ***JVM 기술 스택의 구조***를 이해해야 성능에 대한 배경지식을 갖추게 된다.

---

<!-- footer : 41p -->
## 2.1 인터프리팅과 클래스로딩

- VM스펙 명세에 따르면 JVM은 `스택 기반의 인터프리터`이다. 일부 결과를 실행 스택에 보관하고, 스택의 Top 요소를 가져와 계산한다.  
- 정확히 말하면 JVM은 `스택 기반의 명령어 세트를 가진다.`
  - 출처 : [JDK 21 JVM 스펙 명세](https://docs.oracle.com/javase/specs/jvms/se21/html/jvms-6.html)
  - *jdk 7 ~21 까지 다 뒤져봤는데 `스택 기반의 인터프리터` 와 유사한 표현은 찾을 수 없었다. 명령어 세트가 스택 기반으로 이루어졌다는 설명은 있다.*

---

<!-- footer : 42p -->
## 2.1 인터프리팅과 클래스로딩  

### JVM 인터프리터의 기본 로직  

평가 스택을 이용해 중간값들을 담아둔다. 가장 마지막에 실행된 명령어와 독립적으로 프로그램을 구성하는 옵코드 _opcode_ 를 하나씩 순서대로 처리.  

  - `opcode`란? 프로세서가 수행할 일의 종류를 명시한 코드이다.  
  - `opcode`와 `operand`가 합쳐서 기계 `instruction`이 된다.  
  - 출처 : [wikipedia](https://en.wikipedia.org/wiki/Opcode#:~:text=In%20computing%2C%20an%20opcode%20(abbreviated,the%20operation%20to%20be%20performed.))

> 기본적으로 `while 루프 안의 switch문` 을 연상하자

---

<!-- footer : 42p ~ 43p -->
## 2.1 인터프리팅과 클래스로딩

### `java HelloWorld` 명령이 입력되면 무슨일이 일어날까?

1. OS가 가상머신 프로세스 _자바 바이너리_ 를 구동한다.
2. 자바 가상 환경이 구성되고 스택 머신이 초기화된다.
3. 유저가 작성한 HelloWorld 클래스 파일이 실행된다.
4. **자바 클래스로딩 매커니즘**이 실행된다.
   1. 자바 프로세스가 새로 초기화되면 사슬처럼 줄지어 연결된 클래스로더가 차례차례 작동
   2. 부트스트랩 클래스가 자바 런타임 코어 클래스 로드
   3. 부트스트랩 클래스로더가 최소한의 필수 클래스를 로드하면, 확장 클래스로더가 생성됨
   4. 부트스트랩 클래스로더를 자기 부모로 설정하고 필요할 때 클래스로딩 작업을 부모에게 넘김
   5. 애플리케이션 클래스로더가 생성되고 지정된 클래스패스에 위치만 유저 클래스를 로드

---

<!-- footer : 42p ~ 43p -->
## 2.1 인터프리팅과 클래스로딩  

![bg left:40% 80%](https://docs.oracle.com/cd/E19501-01/819-3659/images/dgdeploy2.gif)

- 자바는 프로그램 실행 중 처음 보는 새 클래스를 dependency에 로드한다.  
- 클래스 찾지 못한 클래스로더는 자신의 부모 클래스로더에게 대신 lookup을 요청한다. 최상위 클래스로더인 부트스트랩도 클래스를 찾지 못하면 `ClassNotFoundException` 에러가 발생한다.  

> 한 시스템에서 클래스는 (패키지명을 포함한) *풀 클래스 명* 과 *자신을 로드한 클래스로더* 두 가지로 식별한다.

---

<!-- footer : 44p -->
## 2.2 바이트코드  실행

### 자바 소스 코드의 실행 단계 

1. 자바 컴파일 (`javac`) : 자바 소스 코드 -> `.class` 형태의 바이트코드 파일
   - 바이트코드 컴파일 단계에서는 최적화는 거의하지 않기 때문에 생성된 바이트 코드는 쉽게 해독 가능(`javap`) 명령어
   - 바이트코드 : 특정 컴퓨터 아키텍처(OS레벨)에 특정하지 않은 중간표현형 _IR_ -intermediate representation -> 자바가 이식성이 좋은이유!


---

<!-- footer : 45p ~ 47p-->
## 2.2 바이트코드  실행

### `.class` 파일 구조  

| Element | Description |
|---------|-------------|
| Magic Number | 0xCAFEBABE(16바이트진수 + 4바이트짜리 버전 숫자) |
| 클래스 파일 format version | class 파일의 major / minor 버젼 |
| 상수 풀(constant pool) | class 파일의 상수가 모여있다 |
| access flag | class modifiers |
| this class | 현재 클래스의 이름 |
| super class | 부모 클래스의 이름 |
| interface | 현재 클래스가 implements 한 모든 interface |
| field | 클래스에 들어가 있는 모든 필드 |
| method | 클래스에 들어가 있는 모든 methods |
| attribute | 클래스의 속성(소스 파일 이름 등) |

- `48p`에서 class 파일 해설하는 부분 참고하기

--- 

<!-- footer : 49p ~ 50p -->
## 2.3 핫스팟 입문  

> 핫스팟 가상 머신은 자바의 요체이다. 개발자가 억지로 VM틀에 맞게 프로그램을 욱여넣는 대신 자연스럽게 자바 코드를 작성하고 바람직한 설계 원리를 따르도록 한다. 

- C/C++의 제로-오버헤드 원칙 : 엄격한 저수준제어, 플랫폼 종속적인 기계어 (AOT 컴파일)
- 핫스팟 VM의 목표 : 프로그램의 런타임 동작을 분석하고 성능에 가장 유리한 방향으로 영리한 최적화를 적용하는 가상머신 


--- 

<!-- footer : 50p ~51p -->
## 2.3.1 JIT 컴파일이란?  

> 핫스팟은 프로그램 단위(메서드와 루프)를 인터프리티드 바이트코드에서 네이티브 코드로 컴파일한다. 바로 JIT _Just-in-time 컴파일이라고 알려진 기술.

- 핫스팟은 인터프리티드 모드로 실행하는 동안 애플리케이션을 모니터링하면서 가장 자주 실행되는 코드 파트를 발견해 JIT 컴파일을 수행한다. 
- 정교한 최적화 : 특정 메서드가 어느 한계치 _threshold_ 를 넘어가면 profiler가 특정 코드 섹션을 컴파일/최적화함. (상황별로 수집한 다양한 정보를 토대로)
- 그리고 `성능을 예측할 수 있는 것이 반드시 더 나은 것`도 아니다. 프로세서에 특정한 기능은 이식성 떨어지기 때문.

> 자바는 동적 인라이닝 _dynamic inlining_ 또는 가상 호출 _vitual call_ 등으로 성능 개선 가능
> 핫스팟 VM이 구동시 CPU 타입을 알아서 정확히 감지해(JVM intrinsics) 프로세서의 기능에 맞게 최적화 적용


--- 

<!-- footer : 52p ~53p -->
## 2.4 JVM 메모리 관리

> C, C++, 오브젝티브-C 개발자는 메모리 할당/해제 작업을 직접 수행 ... 반드시 개발자 메모리를 정확하게 계산해서 처리해야하는 막중한 책임 ... 언어 자체와 씨름하다가 귀중한 시간을 허비

### `GC`란? 
- JVM이 더 많은 메모리를 할당해야 할 때 불필요한 메모리를 회수하거나 재사용하는 불확정적 프로세스

--- 

<!-- footer : 53p ~54p -->
## 2.5 스레딩과 자바 메모리 모델(JMM)

>  **note** 모든 JVM 어플리케이션 스레드의 이면에는 해당 Thread 객체의 start() 메소드가 호출될 때 생성되는 유일한 OS 스레드가 있다.

- JMM의 복잡성 : 기본적으로 객체는 변경 가능 _mutable_ -> 스레드가 생성한 객체를 다른 스레드가 액세스함 -> dangling pointer의 가능성.
-  상호 배타적 락 _mutual exclusion lock_ 은 코드가 동시 실행되는 도중 객체가 손상되는 현상을 막을 수 있는 자바의 유일한 방어 장치지만 실제로 코드에 적용하려면 복잡하다는 단점이 있다.


--- 

<!-- footer : 57p -->
## 2.6.1 JVM 라이선스

> 오라클 JDK와 OpenJDK는 라이선스와 조심해야할 몇 가지 조항 외에는 아무런 차이가 없다. 

--- 

<!-- footer : 58p -->
## 2.7 JVM 모니터링과 툴링

- JMX (자바 관리 확장) : 실시간 애플리케이션 제어(메서드 호출, 매개변수 변경) 및 모니터링, MBean을 통한 성능 지표 확인 및 시스템 관리 기능 제공.
- 자바 에이전트 : `java.lang.instrument`로 메서드 바이트코드조작. JVM 동적 연결, 성능 모니터링, 바이트코드 조작 및 정보 수집.
- JVMTI (JVM 툴 인터페이스) : JVM 내부 이벤트 감시, 디버깅 정보 수집, 시스템 성능 분석.
- SA (서비스 에이전트) : JVM 내부 상태 분석 및 디버깅, 시스템 메모리 및 스레드 상태 정보 제공.