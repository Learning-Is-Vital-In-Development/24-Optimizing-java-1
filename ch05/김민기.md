# Chapter5. 마이크로 벤치마킹과 통계

작은 자바 코드 한 조각의 성능을 정확히 측정(마이크로 벤치마킹)에 대해 알아보자

마이크로벤치마킹 툴의 업계 표준인 JMH(Java Microbenchmark Harness) 사용법을 설명한다.

## 1. 자바 성능 측정 기초

성능 분석은 기초 실험과학 분야로 귀결된 다양한 기술 측면을 종합한 것이다. 벤치마크란 입출력을 지닌 일종의 블랙 박스와도 같다. 어떤 결과를 추측하는데 필요한 데이터를 수집하려고 하지만 데이터를 모으는 것 뿐 아니라 그 데이터에 현혹되지 않도록 주의해야 한다.

목표는 벤치마크로 공정한 테스트를 하는 것이다. 시스템의 한 곳만 변경하고 다른 외부 요인은 벤치마크 안에 두고 통제하면 좋다.

자바 플랫폼을 벤치마크 할 땐 자바 런타임의 정교함이 가장 문제다. 자바 코드 실행은 JIT 컴파일러, 메모리 관리, 그밖의 자바 런타임이 제공하는 서브 시스템과 완전히 떼어놓고 생각할 수 없다. 테스트할 당시 OS, 하드웨어, 런타임 조건의 작용 또한 무시할 수 없다.

보통 벤치마크의 문제점은 JVM 웜업을 고려하지 않은 채 그냥 코드를 테스트했다는 것이다. JIT 컴파일러는 JVM에 내장된 덕분에 인터프리티드 바이트코드는 고도로 최적화된 기계어로 변환된다. JIT 컴파일러는 메서드를 몇 번 실행해본 다음 곧바로 임무를 개시한다.

JIT컴파일러는 코드를 조금이라도 효율적으로 작동시키려고 호출 계층을 최적화 하므로 벤치마크 성능은 캡처 타이밍마다 달라진다. 캡처 로깅을 할 땐 JVM이 웜업을 통해 가동 준비를 마칠 수있게 기간을 두는 게 좋다. 보통 타이밍 세부를 캡처하지 않은 상태로 벤치마크 대상 코드를 여러 번 반복 실행  하는 식으로 JVM을 예열한다.

또 한가지 고려할 외부 요인은 가비지 수집이다. 타이밍 캡처 도중에 GC가 안 일어나게 설정한 다면 좋지만 가비지 수집은 불확정적으로 어찌할 수 없다. GC가 일어날 가능성이 큰 시기에는 타이밍을 캡처하지 않는게 최선이겠다.

벤치마크에서 흔히 저지르는 또 다른 실수는 테스트하려는 코드에서 생성된 결과를 실제로 사용하지 않는 것이다. 방금 벤치마크서 copy는 사실상 죽은 코드이므로 JIT 컴파일러가 이를 죽은 코드 경로로 식별하고 정작 우리가 벤치마크하려던 것을 최적화해버릴 가능성이 있다.

벤치마크 코드를 바로잡는 일은 복잡하고 여러 요인을 고려해야 한다.

해결방안

1. 시스템 전체를 벤치마크한다. 저수준 수치는 수집하지 않는다.
2. 연관된 저수준의 결과를 의미있게 비교하기 위해 앞서 언급한 많은 문제를 공통 프레임워크를 이용해 처리하는 것이다. 이상적인 프레임워크는 몇 가지 문제는 어느 정도 해결할 것이다.

## 2. JMH 소개

위에 소개한 문제를 해결할 수 있는 툴로 JMH가 있다. 그전에 먼저 순진하게 접근하면 마이크로벤치마킹이 얼마나 잘못되기 쉬운지 그 이유는 무엇인지 알아보자

### 2.1 될 수 있으면 마이크로벤치마크하지 말자

신버전의 라이브러리와 기술들로 애플리케이션을 개발했는데 성능이 이전보다 나아지지 않았고, 문제를 찾지못해 소규모 벤치마크를 통해 확인하고 있었지만, CPU 사용률이 정점을 찍고 있다는 사실을 파악해보니 코드의 문제가 아닌 인프라 라이브러리가 문제였다.

### 2.2 휴리스틱:마이크로벤치마킹은 언제할까

일반적으로 저수준 분석이나 마이크로벤치마킹을 하는 주요 유스케이스는 다음 세 가지다.

- 사용 범위가 넓은 범용 라이브러리 코드를 개발한다
- OpenJDK 또는 타 자바 플랫폼 구현체를 개발한다
- 지연에 극도로 민감한 코드를 개발한다 (예: 저지연 거래)

### 2.3 JMH 프레임워크

JMH는 자바를 비롯해 JVM을 타깃으로 하는 언어로 작성된 나노,마이크로,밀리,매크로 벤치마크를 제작,실행,분석하는 자바 도구이다. JVM을 빌드한 사람들이 만든 프레임워크라 JVM버전 별 함정과 최적화 베어 트랩을 피하는지 잘 알고 있다.

### 2.4 벤치마크 실행

JMH는 벤치마크 툴에 관한 몇 가지 핵심적인 설계 이슈를 고려해서 만들었다. 벤치마크 프레임워크는 컴파일 타임에 벤치마크 내용을 알 수 없으므로 동적이어야 한다. 리플렉션을 써서 작성한 벤치마크를 실행하는 우회 방법도 있지만 벤치마크 실행 경로에 복잡한 JVM 서브시스템이 하나 더 끼어들게 된다. 그래서 JMH는 벤치마크 코드에 애너테이션을 붙여 자바 소스를 추가 생성하는 식으로 작동한다. 또한 최적화가 되지 않도록 반복 횟수를 설정한 루프안에 감싸넣어 피한다.

`@Benchmark` 어노테이션으로 프레임워크의 실행시킬 메서드를 나타낸다.

## 3. JVM 성능 통계

모든 측정은 어느 정도의 오차를 수반한다. 다음은 성능 분석 시 흔히 맞닥뜨리는 두 가지 주요 오차 유형이다.

### 3.1 오차 유형

- 랜덤 오차 : 측정 오차 또는 무관계 요인이 어떤 상관관계 없이 결과에 영향을 미친다.
- 계통 오차 : 원인을 알 수 없는 요인이 상관관계 있는 형태로 측정에 영향을 미친다.

> **정확도(accuracy)**는 계통 오차의 수준을 나타내는 용어로, 정확도가 낮으면 오차가 낮은 것
**정밀도(precision)**는 랜덤 오차를 나타내는 용어로, 정밀도가 높으면 랜덤 오차가 낮은 것
>

### …

- 유스케이스를 확실히 모르는 상태에서 마이크로벤치마킹하지 말자
- 그래도 해야한다면 JMH를 이용하자
- 결과를 가능한 많은 사람과 공유하고 동료들과 의논하자
- 항상 잘못된 가능성을 염두에 두고 지속적으로 검증하자